#include <iostream>

using namespace std;

/*
写一个程序查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以从当前点走到左下方的点也可以到达右下方的点:
13
11 8
12 7 26
6 14 15 8
12 7 13 24 11
*/

int dp[1005][1005]; // dp[i][j] 表示从第 i 行第 j 列到底部的路径的最大和
int sz[1005][1005]; // sz[i][j] 表示从第 i 行第 j 列的数字

int main()
{
    int n;

    cin >> n;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> sz[i][j];
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            // 每一个点的路径和等于Current+max(左上, 上)
            // 代价
            dp[i][j] = max(
                dp[i - 1][j],  // 上
                dp[i - 1][j - 1] // 左上
            ) + sz[i][j];
            // cout << dp[i][j] << " ";
        }
        // cout << endl; // 输出look一下
    }

    // 输出DP数组

    // for (int i = 1; i <= n; i++) {
    //     for (int j = 1; j <= i; j++) {
    //         cout << dp[i][j] << " ";
    //     }
    //     cout << endl;
    // }

    // 找最大值

    int max_ = -114514;

    for (int i = 1; i <= n; i++) { // 遍历最后一行
        max_ = max_ > dp[n][i]? max_ : dp[n][i];
    }

    cout << max_ << endl;

    // 搞定收工，回家睡觉
    // 等等，我看看有没有AC。
    // 好像没有AC，我再看看。（PS:555,我的RP）
    // 2024.7.21 14.12：测试样例对了，（先在配套的网站测试，再提交，保护RP），AC没AC待会再说，bye，我去提交了。
    // 555，居然只对了1/3

    // 测试点	结果	内存	时间
    // 测试点1	答案正确	588KB	5MS
    // 测试点2	答案正确	620KB	4MS
    // 测试点3	答案正确	668KB	7MS
    // 测试点4	运行错误	636KB	8MS
    // 测试点5	运行错误	636KB	8MS
    // 测试点6	运行错误	636KB	7MS
    // 测试点7	运行错误	636KB	7MS
    // 测试点8	运行错误	640KB	7MS
    // 测试点9	运行错误	636KB	7MS
    // 测试点10	运行错误	632KB	7MS
    // 我去找找bug，看看是哪里出了问题。

    // 样例又对了，我去提交了。
    // C,原来是数组定义小了，导致数组越界，害我找半天。
    // 去提交了，嘿嘿，佛祖保佑我AC。
    // 嘿嘿，AC了，提交！！！
    // 大功告成！我去睡觉了。
    
    return 0;
}
